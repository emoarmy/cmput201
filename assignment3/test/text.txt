25d24
<     int            pathLength;
27,28c26,28
<     int            indegree;
<     struct tree   *child[7];
---
>     int            totalOverlap;
>     struct tree   *xTraversal;
>     struct tree   *yTraversal;
33a34,37
> 
> 
> RST* calcRST(int** instance, int** MST, int instance_length);
> 
44,47c48
< int findRoot(int** instance, int length);
< 
< //void buildTree(RST* root, int index, int** instance, int** MST,int axis, int length);
< void buildTree(RST* root, int** instance, int** mst, int mst_length);
---
> void calcRSTrecursive(RST* root, int index, int** instance, int** MST,int axis, int length);
63,64d63
< void printTabs(int depth);
< 
139,143c138,139
<     RST* root;
<     int rootIndex = findRoot(MST, plane.instance_size-1);
<     printf("Root index %i\n", rootIndex);
<     root = buildNode(NULL, rootIndex, NULL, 0, 0 );
<     buildTree(root, plane.instance, MST, plane.instance_size-1);
---
>     RST* tree;
>     tree =calcRST(plane.instance, MST, plane.instance_size);
145,146c141,142
<     printList(root,0);
<     // printShortestPath(tree);
---
>     //printList(tree,0);
>     printShortestPath(tree);
152a149,188
> 
> RST* calcRST(int** instance, int** MST, int instance_length){
>     RST* tree = NULL;
>     int index =0;
>     tree =  buildNode(NULL, 0, NULL, 0, 0);
>     calcRSTrecursive(tree, index, instance, MST,0, instance_length-1);
>     calcRSTrecursive(tree, index, instance, MST,1, instance_length-1);
>     return tree;
> }
> // Need to solve where and index comes froms
> void calcRSTrecursive(RST* root, int index, int** instance, int** MST,int axis, int length){
>     if(length ==0){
>         return;
>     } else {
>         RST* newNode;
>         int distance = MST[index][2];
>         int* nodeA = instance[MST[index][0]];
>         int* nodeB = instance[MST[index][1]];
> 
> 
>         Path currentPath = buildPath(nodeA, nodeB, axis);
> 
>         int maxOverlap = findMaxOverlap(root, currentPath, MST, index);
>         int minimizedDistance = distance - maxOverlap;  //Total distance covered so far
> 
>         newNode = buildNode(root, index, currentPath, minimizedDistance, maxOverlap);
>         adjustTotalOverlap(root, maxOverlap);
>         if(axis ==0){
>             root->xTraversal = newNode;
>         } else {
>             root->yTraversal = newNode;
>         }
> 
>         index++;
>         length--;
>         calcRSTrecursive(newNode, index, instance, MST, 0, length);
>         calcRSTrecursive(newNode, index, instance, MST, 1, length);
>     }
> }
> 
203d238
< 
210a246
> 
213,214c249
< 
< int findMaxOverlap(RST* steinerTree, Path* bestPath,int** MST, int mstIndex, int index){
---
> int findMaxOverlap(RST* steinerTree, Path currentPath,int** MST, int index){
218,219c253,264
<     for(int i=0; i < mstIndex; i++){
< 
---
>     if(start < index){
>         do {
>             start++;
>             start= findSharedPath(MST, start, index);
>             if(start >= 0){
>                 int sharedAIndex = findSharedNode(MST, index, start);
>                 overlap = calcOverlap(currentPath, sharedAIndex, steinerTree->path);
>             }
>             if(overlap > maxOverlap){
>                 maxOverlap = overlap;
>             }
>         }while(start != -1 && start < index);
221,235d265
< 
< 
<     // if(start < index){
<     //     do {
<     //         start++;
<     //         start= findSharedPath(MST, start, index);
<     //         if(start >= 0){
<     //             int sharedAIndex = findSharedNode(MST, index, start);
<     //             overlap = calcOverlap(currentPath, sharedAIndex, steinerTree->path);
<     //         }
<     //         if(overlap > maxOverlap){
<     //             maxOverlap = overlap;
<     //         }
<     //     }while(start != -1 && start < index);
<     // }
242a273
> 
287a319
> 
296,302d327
<     newNode->indegree=0;
< 
<     for(int i=0; i< 7; i++){
<         newNode->child[i]=NULL;
<     }
<     return newNode;
< }
304,317c329,330
< void buildTree(RST* root, int** instance, int** mst, int mst_length){
<     for(int i=0; i< mst_length; i++){
<         if(mst[i][0] == root->index){
<             int mstIndex = i;
<             //this must contain a child
<             path = findMaxOverlap();
<             RST* child = buildNode(root, mst[i][1],NULL, mst[i][2], 0);
<             root->child[root->indegree] = child;
<             root->indegree++;
<             buildTree(child, instance, mst, mst_length);
<         }
<     }
<     return;
< };
---
>     newNode->xTraversal = NULL;
>     newNode->yTraversal = NULL;
319,324c332
< void freeMST(int** instance, int length){
<     for(int i =0; i< length; i++){
<         free(instance[i]);
<     }
<     free(instance);
<     return;
---
>     return newNode;
326a335,346
> /* void buildTree(point* root, int** mst, int mst_length){ */
> /*     for(int i=0; i< mst_length; i++){ */
> /*         if(mst[i][0] == root->idx){ */
> /*             //this must contain a child */
> /*             point* child = newPoint(mst[i][1], root, mst[i][2]); */
> /*             root->child[root->indegree] = child; */
> /*             root->indegree++; */
> /*             buildTree(child, mst, mst_length); */
> /*         } */
> /*     } */
> /*     return; */
> /* }; */
360d379
< 
366,372c385,387
<     printTabs(depth);
<     printf("point[%i] has distance %i\n", current->index, current->pathLength);
<     printTabs(depth);
<     if(current->indegree >0){
<         printf("point[%i] has in-degree %i:\n", current->index, current->indegree);
<     } else {
<         printf("point[%i] has in-degree %i//\n", current->index, current->indegree);
---
>     printf("\n");
>     for(int i =0; i< depth; i++){
>             printf("\t");
374,376c389,391
< 
<     for(int j=0; j< current->indegree; j++) {
<         printList(current->child[j], depth+1);
---
>     printf("Node index: %i\n", current->index);
>     for(int i =0; i< depth; i++){
>             printf("\t");
378,380c393,397
< }
< 
< void printTabs(int depth){
---
>     printf("Node distance: %i\n", current->pathLength);
>     for(int i =0; i< depth; i++){
>             printf("\t");
>     }
>     printf("Node maxOverlap %i\n", current->overlap);
383a401,418
>     printf("Node totalOverlap %i\n", current->totalOverlap);
>     for(int i =0; i< depth; i++){
>             printf("\t");
>     }
>     depth++;
>     if(current->path != NULL){
>         printPath(current->path);
>     }
>     if(current->xTraversal != NULL){
>         printList(current->xTraversal, depth);
>     }
>     if(current->yTraversal != NULL){
>         printList(current->yTraversal, depth);
>     }
> }
> 
> void printShortestPath(RST* root){
>     if (root->xTraversal == NULL){
384a420,429
>     }
>     int yOverlap = root->yTraversal->totalOverlap;
>     int xOverlap = root->xTraversal->totalOverlap;
>     if(xOverlap > yOverlap){
>         printPath(root->xTraversal->path);
>         printShortestPath(root->xTraversal);
>     } else{
>         printPath(root->yTraversal->path);
>         printShortestPath(root->yTraversal);
>     }
